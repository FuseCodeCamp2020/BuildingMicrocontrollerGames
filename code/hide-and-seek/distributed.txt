const TEST_MODE = false;
const CAPTURE_RSSI = -45;

interface Client {
    // client serial id
    id: number;
    // whether they are captured yet
    captured: boolean;
    // last signal strength recieved
    lastSignal: number;
}

const clients: Client[] = [];
let selectedClient = -1;
let lastButtonPush = input.runningTime();

/* lazy allocate sprite */
function getClient(id: number): Client {
    // needs an id to track radio client identity
    if (!id)
        return undefined;

    // look for cache clients
    for (const client of clients)
        if (client.id == id) {
            serial.writeLine("Bad id!");
            return client;
        }
    const n = clients.length;
    if (n == 24) {// out of pixels 
        serial.writeLine("Too many clients!");
        return undefined;
    }

    const client: Client = {
        id: id,
        captured: false,
        lastSignal: -128
    }
    clients.push(client);
    serial.writeLine(`Created client ${client.id}`);
    return client;
}

// store data received by clients
radio.onDataPacketReceived(packet => {
    const client = getClient(packet.serial);
    if (!client)
        return;

    client.lastSignal = packet.signal;

    if (selectedClient >= 0) {
        if (client.id == clients[selectedClient].id) {
            //this is a packet from the selected client
            if (client.lastSignal > CAPTURE_RSSI && !client.captured) {
                serial.writeLine("Able to capture client" + client.id);
                if (input.buttonIsPressed(Button.AB)) {
                    client.captured = true;
                    game.addScore(1);
                    //TODO: do i need to disable the game to show this animation?
                    basic.showIcon(IconNames.Yes, 1000);
                    //TODO: auto-select next client? check for game over?
                    //game.showScore();
                }
            }
        }
    }
})

input.onButtonPressed(Button.A, () => {
    lastButtonPush = input.runningTime();
    serial.writeLine("A pushed");
    serial.writeLine(clients.length + " clients connected.");
    //TODO: only allow selection on non captured clients
    if (clients.length > 1) {
        if (selectedClient <= 0) {
            selectedClient = clients.length - 1;
        } else {
            selectedClient--;
        }
    } else if (clients.length == 1) {
        selectedClient = 0;
    } else {
        selectedClient = -1;
    }
})

input.onButtonPressed(Button.B, () => {
    lastButtonPush = input.runningTime();
    serial.writeLine("B pushed");
    serial.writeLine(clients.length + " clients connected.");
    //TODO: only allow selection on non captured clients
    if (clients.length > 1) {
        if (selectedClient == clients.length - 1 || selectedClient < 0) {
            selectedClient = 0;
        } else {
            selectedClient++;
        }
    } else if (clients.length == 1) {
        selectedClient = 0;
    } else {
        selectedClient = -1;
    }
})

input.onShake(() => {
    if (TEST_MODE) {
        //repopulate clients
        if (clients.length == 0) {
            for (let index = 0; index <= 8; index++) {
                getClient(index);
            }
        } else {
            for (let index = 0; index < clients.length; index++) {
                clients[index].lastSignal = Math.random(128) * -1;
            }
        }
    } else {
        //TODO pause the other animation?
        //game.showScore();
    }

})

basic.forever(() => {
    //TODO: need to show something when no clients are connected

    //send out beacon
    if (input.runningTime() % 10 >= 5) {
        serial.writeLine("Sending ping.");
        radio.sendValue("beacon", 0);
    }

    led.stopAnimation();
    let shouldPlot = false;
    if (input.runningTime() - lastButtonPush > 1500) {
        shouldPlot = true;
    }

    //plot the signal strength of currently selected client
    //if recent button push, show the sprite map, blinking the currently selected client
    for (let index = 0; index < clients.length; index++) {
        const client = clients[index];
        if (!shouldPlot) {
            if (client.captured) {
                led.plotBrightness(index % 5, index / 5, 10);
            } else {
                led.plotBrightness(index % 5, index / 5,
                    pins.map(128 + client.lastSignal, 0, 128 - CAPTURE_RSSI, 25, 255));
            }
        }

        if (selectedClient == index) {
            if (shouldPlot) {
                led.plotBarGraph(
                    128 + client.lastSignal,
                    128 - CAPTURE_RSSI
                )
            } else {
                if (input.runningTime() % 4 >= 2) {
                    led.plotBrightness(index % 5, index / 5, 255);
                } else {
                    led.plotBrightness(index % 5, index / 5, 0);
                }
            }
        }
    }
    basic.pause(10)
})

// setup the radio and start!
radio.setGroup(4);
radio.setTransmitPower(7);
radio.setTransmitSerialNumber(true);