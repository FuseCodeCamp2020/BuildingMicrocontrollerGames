const TEST_MODE = true;
const CAPTURE_RSSI = -45;

interface Client {
    // client serial id
    id: number;
    // sprite on screen
    sprite: game.LedSprite;
    // whether they are captured yet
    captured: boolean;
    // last signal strength recieved
    lastSignal: number;
}

const clients: Client[] = [];
let selectedClient = -1;
let lastButtonPush = input.runningTime();

/* lazy allocate sprite */
function getClient(id: number): Client {
    // needs an id to track radio client identity
    if (!id)
        return undefined;

    // look for cache clients
    for (const client of clients)
        if (client.id == id) {
            serial.writeLine("Bad id!");
            return client;
        }
    const n = clients.length;
    if (n == 24) {// out of pixels 
        serial.writeLine("Too many clients!");
        return undefined;
    }

    const client: Client = {
        id: id,
        sprite: game.createSprite(n % 5, n / 5),
        captured: false,
        lastSignal: -128
    }
    clients.push(client);
    serial.writeLine(`Created client ${client.id}`);
    return client;
}

// store data received by clients
radio.onDataPacketReceived(packet => {
    const client = getClient(packet.serial);
    if (!client)
        return;

    client.lastSignal = packet.signal;
    client.sprite.setBrightness(pins.map(packet.signal, -128, -40, 10, 255));

    if (selectedClient >= 0) {
        if (client.id == clients[selectedClient].id) {
            //this is a packet from the selected client
            if (client.lastSignal > CAPTURE_RSSI && !client.captured) {
                serial.writeLine("Able to capture client" + client.id);
                if (input.buttonIsPressed(Button.AB)) {
                    client.captured = true;
                    game.addScore(1);
                    //TODO: do i need to disable the game to show this animation?
                    basic.showIcon(IconNames.Yes, 1000);
                    //TODO: auto-select next client? check for game over?
                    //game.showScore();
                }
            }
        }
    }
})

input.onButtonPressed(Button.A, () => {
    lastButtonPush = input.runningTime();
    game.resume();
    //TODO: only allow selection on non captured clients
    if (clients.length > 1) {
        if (selectedClient <= 0) {
            selectedClient = clients.length - 1;
        } else {
            selectedClient--;
        }
    } else if (clients.length == 1) {
        selectedClient = 0;
    } else {
        selectedClient = -1;
    }
})

input.onButtonPressed(Button.B, () => {
    lastButtonPush = input.runningTime();
    game.resume();
    //TODO: only allow selection on non captured clients
    if (clients.length > 1) {
        if (selectedClient == clients.length - 1 || selectedClient < 0) {
            selectedClient = 0;
        } else {
            selectedClient++;
        }
    } else if (clients.length == 1) {
        selectedClient = 0;
    } else {
        selectedClient = -1;
    }
})

input.onShake(() => {
    if (TEST_MODE) {
        //repopulate clients
        if (clients.length == 0) {
            for (let index = 0; index <= 8; index++) {
                getClient(index);
            }
        } else {
            for (let index = 0; index < clients.length; index++) {
                clients[index].lastSignal = Math.random(128) * -1;
            }
        }
    } else {
        //TODO pause the other animation?
        //game.showScore();
    }

})

basic.forever(() => {
    let shouldPlot = false;
    if (input.runningTime() - lastButtonPush > 1500) {
        game.pause();
        shouldPlot = true;
    }

    //plot the signal strength of currently selected client
    //if recent button push, show the sprite map, blinking the currently selected client
    for (let index = 0; index < clients.length; index++) {
        const client = clients[index];
        client.sprite.setBlink(0);

        if (client.captured) {
            client.sprite.setBrightness(10);
        } else {
            client.sprite.setBrightness(pins.map(128 + client.lastSignal, 0, 128 - CAPTURE_RSSI, 10, 255));
        }
        //serial.writeLine(`Client ${index} has brightness of` + client.sprite.brightness());

        if (selectedClient == index) {
            client.sprite.setBlink(100);
            if (shouldPlot) {
                led.plotBarGraph(
                    128 + client.lastSignal,
                    128 - CAPTURE_RSSI
                )
            }
        }
    }
    basic.pause(250)
})

// setup the radio and start!
radio.setGroup(4);